use ::std::fs;

use ::indoc::indoc;

fn main() {
    generate_compatibility_tests();
}

fn generate_compatibility_tests() {
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=Cargo.lock");
    println!("cargo:rerun-if-changed=test_files");

    let out_dir = std::env::var_os("OUT_DIR").unwrap();
    let out_pth = std::path::Path::new(&out_dir).join("compatibility_tests.rs");

    let paths = fs::read_dir("./test_files/")
        .unwrap()
        .into_iter()
        .map(|pth| pth.unwrap().path().canonicalize().unwrap())
        .filter(|pth| pth.is_file())
        .filter(|pth| pth.to_string_lossy().contains("original_v"))
        .collect::<Vec<_>>();
    assert!(!paths.is_empty());
    let mut test_code = vec![indoc!(
        "\
        // This file is automatically @generated by build.rs' generate_compatibility_tests.
        use ::std::env::set_current_dir;
        use ::std::path::PathBuf;
        use crate::compile_current_dir;
        "
    )
        .to_owned()];
    for path in paths {
        let path_txt = path.to_str().unwrap();
        println!("cargo:rerun-if-changed={}", path_txt);
        let name = path.file_name().unwrap().to_string_lossy();
        test_code.push(format!(
            indoc!(r#"
            #[test]
            fn compat_test_{}() {{
                set_current_dir(&PathBuf::from("{}")).unwrap();
                compile_current_dir();
            }}
            "#
            ),
            name, path_txt
        ));
    }
    fs::write(&out_pth, test_code.join("\n")).unwrap();
}
