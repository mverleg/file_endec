use ::std::fs;

use ::indoc::indoc;

use ::lazy_static::lazy_static;
use ::regex::Regex;

lazy_static! {
    static ref COMPAT_FILE_RE: Regex = Regex::new(r"^original_v(\d+\.\d+\.\d+)(_\w*)?.png$").unwrap();
}

fn main() {
    generate_compatibility_tests();
}

fn generate_compatibility_tests() {
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=Cargo.lock");
    println!("cargo:rerun-if-changed=test_files");

    let out_dir = std::env::var_os("OUT_DIR").unwrap();
    let out_pth = std::path::Path::new(&out_dir).join("compatibility_tests.rs");

    let paths = fs::read_dir("./test_files/")
        .unwrap()
        .into_iter()
        .map(|pth| pth.unwrap().path().canonicalize().unwrap())
        .filter(|pth| pth.is_file())
        .filter(|pth| pth.to_string_lossy().contains("original_v"))
        .collect::<Vec<_>>();
    assert!(!paths.is_empty());
    let mut test_code = vec![indoc!(
        "\
        // This file is automatically @generated by build.rs' generate_compatibility_tests.

        use ::std::fs;
        use ::std::fs::File;
        use ::std::io::Read;
        use ::std::path::Path;

        use ::lazy_static::lazy_static;
        use ::regex::Regex;
        use ::tempfile::tempdir;

        use crate::config::DecryptConfig;
        use crate::decrypt;
        use crate::header::strategy::Verbosity;
        use crate::key::key::Key;
        use crate::config::typ::{InputAction, OnFileExist};

        lazy_static! {
            static ref COMPAT_KEY: Key = Key::new(\" LP0y#shbogtwhGjM=*jFFZPmNd&qBO+ \");
        }
        "
    )
        .to_owned()];
    for path in paths {
        let path_txt = path.to_str().unwrap();
        println!("cargo:rerun-if-changed={}", path_txt);
        let name = path.file_name().unwrap().to_string_lossy().to_string();
        let name = name[9 .. name.len()-8].replace(".", "_");
        test_code.push(format!(
            indoc!(r#"
            #[test]
            fn compat_test_{}() {{
                let out_dir = tempdir::TempDir::new().unwrap();
                let enc_pth = PathBuf::from("{}");
                let mut original_pth = enc_pth.clone();
                original_pth.pop();
                original_pth.push("original.png".to_owned());
                let conf = DecryptConfig::new(
                    vec![enc_pth.to_owned()],
                    COMPAT_KEY.clone(),
                    Verbosity::Debug,
                    OnFileExist::Overwrite,
                    InputAction::Keep,
                    Some(out_dir),
                );
                let dec_pths = decrypt(&conf).unwrap();
                assert_eq!(dec_pths.len(), 1);
                let dec_pth = dec_pths.first().unwrap();
                let mut original_data = vec![];
                File::open(&original_pth)
                    .unwrap()
                    .read_to_end(&mut original_data)
                    .unwrap();
                let mut dec_data = vec![];
                File::open(&dec_pth)
                    .unwrap()
                    .read_to_end(&mut dec_data)
                    .unwrap();
                assert_eq!(&original_data, &dec_data);
                fs::remove_file(&dec_pth).unwrap();
            }}
            "#
            ),
            name, path_txt
        ));
    }
    fs::write(&out_pth, test_code.join("\n")).unwrap();
}
